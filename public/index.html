<!DOCTYPE html>
<html>
  <head>
    <title>Socket.IO</title>
    <style>
      body {
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          margin: 0;
          font-family: Arial, sans-serif;
          background-color: #f0f0f0;
      }

      .container {
          text-align: center;
          background: #fff;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      input {
          width: 80%;
          padding: 10px;
          margin: 10px 0;
          border: 1px solid #ccc;
          border-radius: 4px;
      }

      button {
          padding: 10px 20px;
          background-color: #28a745;
          border: none;
          border-radius: 4px;
          color: white;
          font-size: 16px;
          cursor: pointer;
      }

      button:hover {
          background-color: #218838;
      }
      #grid-container {
          position: relative;
          width: 100vw;
          height: 100vh;
          overflow: hidden;
      }
      #grid {
          width: 500vw;
          height: 500vw;
          position: absolute;
          top: -250vw;
          left: -250vw;
          -khtml-user-select: none;
          -o-user-select: none;
          -moz-user-select: none;
          -webkit-user-select: none;
          user-select: none;
      }
      .image-chunk {
          width: 125vw; /* Adjusted for 16 chunks in total */
          height: 125vw;
          background-color: #f0f0f0; /* Placeholder background */
          position: absolute;
      }
    </style>
  </head>
  <body>
    <div id='start'class="container">
        <h1>Welcome to Deip.io 3!</h1>
        <input type="text" id="username" placeholder="Enter your username">
        <button id="playButton">Play</button>
    </div>
    <div id='game' style='display:none'>
      <img src='you died.gif' style='width:99.9vw; position:absolute; height:99.9vh; top:0; left:0;  display: none;' id='die'/>
      <div style='overflow: hidden; width:99.9vw; height:99.9vh; top:0; left:0; position:absolute;' id='container'>
      <p id='players' style='z-index:100000000000; position:absolute; top:0; left:0;'>players:0</p>
        <div style='display: grid;
          grid-template-columns: repeat(125, 80px);
          grid-template-rows: repeat(125, 80px);
          grid-gap: 0px;
          width:10000px;height:10000px;position:absolute; top: -5000px; left: -5000px;' id='grid'></div>
        </div>
    </div>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      var username = "Unamed tank"
      for (let i = 0; i < 125; i++) {
        for (let j = 0; j < 125; j++) {
          const div = document.createElement('div');
          div.style.width = '79px';
          div.style.height = '79px';
          div.style.backgroundColor = 'white';
          div.style.border = '1px solid black';
          document.getElementById("grid").appendChild(div);
        }  
      } 
      function ongame() {

      
        function disableScroll() {
          // Get the current page scroll position in the vertical direction
          scrollTop =
            window.scrollY || document.documentElement.scrollTop;
  
  
          // Get the current page scroll position in the horizontal direction 
  
          scrollLeft =
            window.scrollX || document.documentElement.scrollLeft;
  
  
          // if any scroll is attempted,
          // set this to the previous value
          window.onscroll = function() {
            window.scrollTo(scrollLeft, scrollTop);
          };
        }
        //disableScroll();
        const socket = io(); // Connect to the server
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        document.getElementById('game').appendChild(canvas);
        canvas.id = 'myCanvas'
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
  
        var players = {};
        var boardbullets = [];
        var bullets = [];
        var food_list = [];
        var playerId;
        var playerX = canvas.width / 2;
        var playerY = canvas.height / 2;
        var cavansX = 0;
        var cavansY = 0;
        var playerHealth = 100;
        var playerSpeed = 10;
        var playerSize = 1;
        var bodyDamage = 3;
        var type = 'basic'
        var bullet_damage = 1.5;
        var bullet_speed = 8;
        var bullet_size = 0.18;
        var bullet_pentration = 2;
        var bullet_power = (bullet_speed/5.5)+bullet_damage*(bullet_pentration/10)
        var cannonWidth = 99;
        var cannonHeight = 30;
        var current_angle = 0;
        var MouseX_ = 0;
        var MouseY_ = 0;
        var mapLeft =  -5000; // This could be zero if you don't want any margin at the left
        var mapRight =  5000;
        var mapTop =   -5000; // Similar to mapLeft, this could be zero
        var mapBottom = 5000;
        var playerMovementX = 0; 
        var playerMovementY = 0; 
        var score = 0;
        console.log(mapRight,mapBottom/2)
        

        // Update grid position
        setInterval(() => {
            grid.style.top = `calc(-5000px - ${cavansY}px)`;
            grid.style.left = `calc(-5000px - ${cavansX}px)`;
        }, 10);
  
        function getMousePos(canvas, evt) {
          const rect = canvas.getBoundingClientRect();
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
          };
        }
        document.addEventListener('dblclick', function(evt) {
          evt.preventDefault();
        });
  
  
  
        socket.on('connect', () => {
          playerId = socket.id;
          socket.emit('newPlayer', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
          setTimeout(function () {
            socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
          }, 200);
          
          draw() // Call draw after connecting
        });
        socket.on('playerJoined', (data) => {
          players[data.id] = data;
          setTimeout(function () {
            socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
          }, 200);
        });
        socket.on('playerMoved', (data) => {
          players[data.id] = data;
        });
        socket.on('playerCannonUpdated', (data) => {
          players[data.id].cannon_angle = data.cannon_angle;
          players[data.id].type = data.type;
          players[data.id].cannonH = data.cannonH;
          players[data.id].cannonW = data.cannonW;
        });
        socket.on('playerLeft', (id) => {
          delete players[id];
        });
        socket.on('playerDamaged', (data) => {
          console.log("self:",players[data.player1.id].health,"other:",players[data.player2.id].health)
          players[data.player1.id].health = data.player1.health;
          if (data.player2.id === playerId) {
            playerHealth = data.player2.health;
          }
          if (data.player1.id === playerId) {
            playerHealth = data.player1.health;
          }
          players[data.player2.id].health = data.player2.health; 
        });
        socket.on('bulletUpdate', (data) => {
          bullets = data;
        });
        socket.on('playerScore', (data) => {
          console.log(players[data["bulletId"]],data)
          players[data["bulletId"]].score += data["socrepluse"];
          if (data["bulletId"] === playerId) {
            score = players[data["bulletId"]].score;
          }
          //console.log("data",players[data].score)
        })
        socket.emit('getFood', {});
        socket.on('FoodUpdate', (data) => {
          food_list = data;
          console.log("food_list",food_list.length)
        });
        socket.on('bulletDamage', (data) => {
          console.log(players)
          console.log("hit")
          if (players[data.playerID]) {
            bullets = data.BULLETS; // Check if the player exists
            players[data.playerID].health = data.playerHealth;
            console.log("current-health",players[data.playerID].health)
            if (data.playerID == playerId) {
              playerHealth = data.playerHealth;
            }
          } else {
            console.warn("Received bulletDamage for an unknown player:", data.playerID);
          }
        });
        let keysPressed = {};
        document.addEventListener('keydown', (event) => {
          console.log(event.key)
          keysPressed[event.key] = true;
          
          if      (keysPressed['ArrowLeft'] && keysPressed['ArrowUp'] || keysPressed['a'] && keysPressed['w']) {
            if (playerX > mapLeft && playerY > mapTop) {
              playerMovementX += -(11); 
              playerMovementY += -(11); 
              playerX -= 1;
              cavansX -= 1;
              playerY -= 1;
              cavansY -= 1;
  
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerX -= 1;
                  cavansX -= 1;
                  playerY -= 1;
                  cavansY -= 1;
                },  i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {

                        //playerHealth -= player.bodyDamage;
                        socket.emit('playerCollided', {
                          id_other: playerId_,
                          damagetaken: player.bodyDamage,
                          damagegiven: bodyDamage,
                          speed: playerSpeed,
                          health: players[playerId].health,
                          id_self: playerId,
                        });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerX += 1;
                              cavansX += 1;
                              playerY += 1;
                              cavansY += 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth-(player.bodyDamage/t), speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        }, 1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, 15);
            }
          }
          else if (keysPressed['ArrowLeft'] && keysPressed['ArrowDown'] || keysPressed['a'] && keysPressed['s']) {
            if (playerX > mapLeft && playerY < mapBottom) {
              playerMovementX += -(11); 
              playerMovementY += (11); 
              playerX -= 1;
              cavansX -= 1;
              playerY += 1;
              cavansY += 1;
  
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerX -= 1;
                  cavansX -= 1;
                  playerY += 1;
                  cavansY += 1;
                  
                },  i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {

                      //playerHealth -= player.bodyDamage;
                        socket.emit('playerCollided', {
                          id_other: playerId_,
                          damagetaken: player.bodyDamage,
                          damagegiven: bodyDamage,
                          speed: playerSpeed,
                          health: players[playerId].health,
                          id_self: playerId,
                        });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerX += 1;
                              cavansX += 1;
                              playerY -= 1;
                              cavansY -= 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        }, 1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, 15);
            }
          }
          else if (keysPressed['ArrowRight'] && keysPressed['ArrowUp'] || keysPressed['d'] && keysPressed['w']) {
            if (playerX < mapRight && playerY > mapTop) {
              playerMovementX += (11); 
              playerMovementY += -(11); 
              playerX += 1;
              cavansX += 1;
              playerY -= 1;
              cavansY -= 1;
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerX += 1;
                  cavansX += 1;
                  playerY -= 1;
                  cavansY -= 1;
                },  i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {
                      //playerHealth -= player.bodyDamage;
                      socket.emit('playerCollided', {
                        id_other: playerId_,
                        damagetaken: player.bodyDamage,
                        damagegiven: bodyDamage,
                        speed: playerSpeed,
                        health: players[playerId].health,
                        id_self: playerId,
                      });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerX -= 1;
                              cavansX -= 1;
                              playerY -= 1;
                              cavansY -= 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        },1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                console.log(__angle___);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, 15);
            }
          }
          else if (keysPressed['ArrowRight'] && keysPressed['ArrowDown'] || keysPressed['d'] && keysPressed['s']) {
            if (playerX < mapRight && playerY < mapBottom) {
              playerMovementX += (11); 
              playerMovementY += (11); 
              playerX += 1;
              cavansX += 1;
              playerY += 1;
              cavansY += 1;
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerX += 1;
                  cavansX += 1;
                  playerY += 1;
                  cavansY += 1;
                }, i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {
                      //playerHealth -= player.bodyDamage;
                      socket.emit('playerCollided', {
                        id_other: playerId_,
                        damagetaken: player.bodyDamage,
                        damagegiven: bodyDamage,
                        speed: playerSpeed,
                        health: players[playerId].health,
                        id_self: playerId,
                      });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerX -= 1;
                              cavansX -= 1;
                              playerY -= 1;
                              cavansY -= 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        }, 1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                console.log(__angle___);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, 15);
            }
          }
          else if (keysPressed['ArrowUp'] || keysPressed['w']) {
            if (playerY > mapTop) {
              playerMovementY += (11); 
              playerY -= 1;
              cavansY -= 1;
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerY -= 1;
                  cavansY -= 1;
                },  i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {

                      //playerHealth -= player.bodyDamage;
                        socket.emit('playerCollided', {
                          id_other: playerId_,
                          damagetaken: player.bodyDamage,
                          damagegiven: bodyDamage,
                          speed: playerSpeed,
                          health: players[playerId].health,
                          id_self: playerId,
                        });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerY += 1;
                              cavansY += 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        }, 1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, playerSpeed*10)
            }
          }
          else if (keysPressed['ArrowDown'] || keysPressed['s']) {
            if (playerY < mapBottom) {
              playerMovementY += (11); 
              playerY += 1;
              cavansY += 1;
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerY += 1;
                  cavansY += 1;
                },  i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {

                        //playerHealth -= player.bodyDamage;
                        socket.emit('playerCollided', {
                          id_other: playerId_,
                          damagetaken: player.bodyDamage,
                          damagegiven: bodyDamage,
                          speed: playerSpeed,
                          health: players[playerId].health,
                          id_self: playerId,
                        });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerY -= 1;
                              cavansY -= 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        }, 1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, playerSpeed*10)
            }
          } 
          else if (keysPressed['ArrowLeft'] || keysPressed['a']) {
            if (playerX > mapLeft) {
              playerMovementX += -(11); 
              playerX -= 1;
              cavansX -= 1;
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerX -= 1;
                  cavansX -= 1;
                },  i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {

                      //playerHealth -= player.bodyDamage;
                        socket.emit('playerCollided', {
                          id_other: playerId_,
                          damagetaken: player.bodyDamage,
                          damagegiven: bodyDamage,
                          speed: playerSpeed,
                          health: players[playerId].health,
                          id_self: playerId,
                        });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerX += 1;
                              cavansX += 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        }, 1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, playerSpeed*10);
            }
          }
          else if (keysPressed['ArrowRight'] || keysPressed['d']) {
            if (playerX < mapRight) {
              playerMovementX += (11); 
              playerX += 1;
              cavansX += 1;
              for (let i = 1; i < playerSpeed; i++) {
                setTimeout(() => {
                  playerX += 1;
                  cavansX += 1;
                },  i*10)
              }
              setTimeout(() => {
                for (let playerId_ in players) {
                    var player = players[playerId_];
                    if (Math.abs(player.x - playerX) < (player.size*40 + playerSize*40) 
                        && Math.abs(player.y - playerY) < (player.size*40 + playerSize*40) && playerId_ != playerId) {
                      //players[playerId].health -= player.bodyDamage; // Keeped for revision, don't remove
                      //playerHealth -= player.bodyDamage;
                      socket.emit('playerCollided', {
                        id_other: playerId_,
                        damagetaken: player.bodyDamage,
                        damagegiven: bodyDamage,
                        speed: playerSpeed,
                        health: players[playerId].health,
                        id_self: playerId,
                      });
                        setTimeout(() => {
                          for (let t = 0; t < playerSpeed; t++) {
                            setTimeout(() => {
                              playerX -= 1;
                              cavansX -= 1;
                              socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:current_angle, score:score, username:username });
                            },(t)*10);
                          }
                        }, 1);
                    }
                }
                let __angle___ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
                console.log(__angle___);
                socket.emit('playerMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle___, score:score, username:username });
              }, playerSpeed*10);
            }
          }
        });
  
        document.addEventListener('keyup', (event) => {
          delete keysPressed[event.key];
          console.log(event.key)
          if (event.key === 'ArrowUp' || event.key === 'w') {
            playerMovementY = 0;
          }
          else if (event.key === 'ArrowDown' || event.key === 's' ) {
            playerMovementY = 0;
          } 
          else if (event.key === 'ArrowLeft' || event.key ==='a') {
            playerMovementX = 0;
          }
          else if (event.key === 'ArrowRight' || event.key ==='d') {
            playerMovementX = 0;
          }
        });
  
  
        let canW = canvas.width
        let canH = canvas.height
        let squareColor = 'grey';
  
        document.addEventListener('mousemove', function(evt) {
          var mousepos = getMousePos(document.getElementById("container"), evt);
          MouseX_ = mousepos.x;
          MouseY_ = mousepos.y;
          let __angle__ = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
          socket.emit('playerCannonMoved', { id: playerId, x: playerX, y: playerY, health: playerHealth, speed: playerSpeed, size: playerSize, bodyDamage: bodyDamage, cannonW: cannonWidth, cannonH: cannonHeight, type: type, cannon_angle:__angle__, score:score, username:username });
        });
  
  
        let canFire = true;
        let canFire2 = true;
        let firingInterval = null; // Store the interval id
  
        document.addEventListener('mousedown', function (evt) {
          console.log(canFire)
          if (canFire) {
            canFire = false;
            // Calculate bullet data only once
            let bullet_distance = (bullet_damage + bullet_speed*8.5) * ((bullet_pentration / bullet_size*2));
            console.log((bullet_damage + bullet_speed*8.5) * ((bullet_pentration / bullet_size*2)))
            let cannon_length = cannonWidth / 2 + 30;
  
            var mouse = getMousePos(canvas, evt);
            mouseX = mouse.x;
            mouseY = mouse.y;
            let bullet_start_x = playerX + 0 * Math.cos(current_angle);
            let bullet_start_y = playerY + 0 * Math.sin(current_angle);
            let angle = Math.atan2(Math.abs(mouseY) - (248), Math.abs(mouseX) - 511.25);
            var identdfire = Date.now() + Math.random();
  
            for (let l = 0; l < 10; l++) {
              setTimeout(() => {
                cannonWidth -= 1
              },10*l)
            }
            for (let l = 0; l < 10; l++) {
              setTimeout(() => {
                cannonWidth += 1
              },10*(l*2))
            }
  
            // Fire the bullet
            bullets.push({
              bullet_distance: bullet_distance,
              speed: bullet_speed,
              size: bullet_size,
              angle: angle,
              bullet_damage: bullet_damage,
              distanceTraveled: 0,
              bullet_pentration: bullet_pentration,
              x: bullet_start_x,
              y: bullet_start_y,
              xstart:  cavansX,
              ystart:  cavansY,
              id: playerId,
              uniqueid: identdfire
            });
            socket.emit('bulletFired', {
              bullet_distance: bullet_distance,
              speed: bullet_speed,
              size: bullet_size,
              angle: angle,
              bullet_damage: bullet_damage,
              distanceTraveled: 0,
              bullet_pentration: bullet_pentration,
              x: bullet_start_x,
              y: bullet_start_y,
              xstart:  cavansX,
              ystart:  cavansY,
              id: playerId,
              uniqueid: identdfire
            });
            setTimeout(() => {
              canFire = true;
            }, 500);
          }
        });
        document.addEventListener('mousedown', (evt) => {
          firingInterval = setInterval((event=evt) => {
            canFire2 = false;
            // Re-calculate bullet data for each bullet fired
            let bullet_distance = (bullet_damage + bullet_speed*8.5) * ((bullet_pentration/(bullet_size)));
            let cannon_length = cannonWidth / 2 + 30;
  
            var mouse = getMousePos(canvas, evt);
            mouseX = mouse.x;
            mouseY = mouse.y;
  
            for (let l = 0; l < 10; l++) {
              setTimeout(() => {
                cannonWidth -= 2
              },10*l)
            }
            for (let l = 0; l < 10; l++) {
              setTimeout(() => {
                cannonWidth += 2
              },10*(l*2))
            }
  
            let bullet_start_x = playerX + 0 * Math.cos(current_angle);
            let bullet_start_y = playerY + 0 * Math.sin(current_angle);
            let angle = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25);
            var identdfire = Date.now() + Math.random();
  
            bullets.push({
              bullet_distance: bullet_distance,
              speed: bullet_speed,
              size: bullet_size,
              angle: angle,
              bullet_damage: bullet_damage,
              distanceTraveled: 0,
              bullet_pentration: bullet_pentration,
              x: bullet_start_x,
              y: bullet_start_y,
              xstart:  cavansX,
              ystart:  cavansY,
              id: playerId,
              uniqueid: identdfire
            });
            socket.emit('bulletFired', {
              bullet_distance: bullet_distance,
              speed: bullet_speed,
              size: bullet_size,
              angle: angle,
              bullet_damage: bullet_damage,
              distanceTraveled: 0,
              bullet_pentration: bullet_pentration,
              x: bullet_start_x,
              y: bullet_start_y,
              xstart:  cavansX,
              ystart:  cavansY,
              id: playerId,
              uniqueid: identdfire
            });
          }, 500);
        });
  
        document.addEventListener('mouseup', function (evt) {
          if (firingInterval) {
            clearInterval(firingInterval);
            firingInterval = null;
            canFire2 = true;
          }
        });
        
        
  
        // Function to update bullet positions
  
        // Function to draw the bullet
  
        const radius = 40;
        
        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          food_list.forEach((item) => {
            if (item.x > 0+cavansX && item.x < canvas.width+cavansX && item.y-cavansY > 0 &&
                item.y < canvas.height+cavansY && item.health > 0) {
              if (item.type === 'square') {
                // Drawing the square
                ctx.save();
                ctx.translate(item.x - cavansX, item.y - cavansY);
                ctx.rotate(item.angle * Math.PI / 180);
                ctx.fillStyle = item.color;
                ctx.fillRect(-item.size / 2, -item.size / 2, item.size, item.size);  // Center the square
                ctx.strokeStyle = 'GoldenRod';
                ctx.lineWidth = 5;
                ctx.strokeRect(-item.size / 2, -item.size / 2, item.size, item.size);  // Center the stroke

                ctx.fillStyle = 'black';
                ctx.rotate((-item.angle) * Math.PI / 180);
                if (item.health < 10) {
                    ctx.fillRect(-45, 35, 90, 10);  // Adjusted for centered square
                    const healthWidth = (item.health / 10) * 90;
                    ctx.fillStyle = 'green';
                    ctx.fillRect(-45, 35, healthWidth, 10);  // Adjusted for centered square
                }
                ctx.restore();
              }
              if (item.type === 'triangle') {
                ctx.save();

                // Translate to the center of the square
                ctx.translate(item.x - cavansX, item.y - cavansY);

                ctx.rotate(item.angle * Math.PI / 180);
                ctx.beginPath();
                ctx.fillStyle = item.color;
                ctx.moveTo(0, 0);
                ctx.lineTo(0 + item.size, 0);
                ctx.lineTo(0 + item.size / 2, 0 - (Math.sqrt(3) * item.size) / 2);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.strokeStyle = 'Darkred';
                ctx.moveTo(0, 0);
                ctx.lineTo(0 + item.size, 0);
                ctx.lineTo(0 + item.size / 2, 0 - (Math.sqrt(3) * item.size) / 2);
                ctx.closePath();
                ctx.stroke();

                ctx.restore();
                if (item.health < 10) {

                  ctx.fillStyle = 'black';
                  ctx.fillRect((item.x - cavansX) - 25, (item.y - cavansY) + 55, 90, 10);

                  // Draw health bar
                  const healthWidth = (item.health / 10) * 90;
                  ctx.fillStyle = 'green';
                  ctx.fillRect((item.x - cavansX) - 25, (item.y - cavansY) + 55, healthWidth, 10);
                }
              }
            }
          });
          bullets.forEach((bullet) => {
            if (bullet.x > 0+cavansX && bullet.x < canvas.width+cavansX && bullet.y-cavansY > 0 && bullet.y < canvas.height+cavansY) {
            ctx.beginPath();
            if (bullet.id === playerId) {
              ctx.fillStyle = 'blue';
              ctx.strokeStyle = 'darkblue';
            } else {
              ctx.fillStyle = 'red';
              ctx.strokeStyle = 'darkred';
            }
            /*console.log(bullet.xstart,bullet.ystart)
            if (bullet.xstart-cavansX > 0) {
              var x___ = (Math.abs(bullet.xstart-cavansX))
            } else if (bullet.xstart-cavansX < 0) {
              var x___ = (Math.abs(bullet.xstart-cavansX))
            } else {
              var x___ = cavansX
            }
            if (bullet.ystart-cavansY > 0) {
              var y___ = (bullet.xstart + Math.abs(bullet.ystart-cavansY))
            } else if (bullet.ystart-cavansY < 0) {
              var y___ = (Math.abs(bullet.ystart-cavansY))
            } else {
              var y___ = cavansY
            }*/
            ctx.arc(bullet.x - (bullet.xstart-(bullet.xstart-cavansX)), 
                    bullet.y - (bullet.ystart-(bullet.ystart-cavansY)), 
                    bullet.size * cannonWidth, 0, 2 * Math.PI);
            ctx.fill();
            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.closePath();
            }
          });
          try {
            for (let playerId__ in players) {
              if (players.hasOwnProperty(playerId__) && playerId__ != playerId) {
  
                let player = players[playerId__];
  
  
                let r = Math.PI / 180;
                ctx.fillStyle = squareColor;
  
                // Save the current transformation matrix
                ctx.save();
  
  
  
                // Translate to the center of the square
                ctx.translate(player.x-cavansX, player.y-cavansY);
  
                // Calculate the angle to rotate the square to face the mouse pointer
  
                let angle = player.cannon_angle;
  
                ctx.rotate(angle);
  
                // Draw the square
                ctx.fillRect((-player.cannonW / 2)+30, (-player.cannonH / 2), player.cannonW, player.cannonH);
  
                // Add a border to the cannon
                ctx.strokeStyle = 'lightgrey'; // Set border color
                ctx.lineWidth = 3; // Set border width
                ctx.strokeRect((-player.cannonW / 2)+30, (-player.cannonH / 2), player.cannonW, player.cannonH); // Draw the border
  
                // Restore the previous transformation matrix
                ctx.restore();
  
                ctx.beginPath();
                ctx.arc(player.x - cavansX, player.y - cavansY, player.size * 40, 0, 2 * Math.PI, false);
                ctx.fillStyle = 'red';
                ctx.fill();
                ctx.lineWidth = 5;
                ctx.strokeStyle = 'darkred';
                ctx.stroke();
  
                // Draw background bar
                ctx.fillStyle = 'black';
                ctx.fillRect((player.x - cavansX) - 50, (player.y - cavansY) + 55, 90, 10);
  
                // Draw health bar
                const healthWidth = (player.health / 100) * 90;
                ctx.fillStyle = 'green';
                ctx.fillRect((player.x - cavansX) - 50, (player.y - cavansY) + 55, healthWidth, 10);
  
                ctx.fillStyle = 'black';
                ctx.textAlign = "center";
                ctx.font = "bold 20px Geneva";
                ctx.fillText(player.score, (player.x - cavansX), (player.y - cavansY) - 55);
  
                ctx.fillText(player.username, (player.x - cavansX), (player.y - cavansY) - 75);
  
                // Draw border
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'grey';
                ctx.strokeRect((player.x - cavansX) - 50, (player.y - cavansY) + 55, 90, 10);
  
  
              }
            }
          } catch(e) {
            console.error("error:",e)
          }
  
          let r = Math.PI / 180;
          ctx.fillStyle = squareColor;
  
          // Save the current transformation matrix
          ctx.save();
  
  
  
          // Translate to the center of the square
          ctx.translate((canW / 2), (canH / 2));
  
          // Calculate the angle to rotate the square to face the mouse pointer
  
          let angle = Math.atan2(Math.abs(MouseY_) - (248), Math.abs(MouseX_) - 511.25); // Fixed line
  
          // Rotate the canvas
          ctx.rotate(angle);
  
          // Draw the square
          ctx.fillRect((-cannonWidth / 2)+30, (-cannonHeight / 2), cannonWidth, cannonHeight);
  
          // Add a border to the cannon
          ctx.strokeStyle = 'lightgrey'; // Set border color
          ctx.lineWidth = 3; // Set border width
          ctx.strokeRect((-cannonWidth / 2)+30, (-cannonHeight / 2), cannonWidth, cannonHeight); // Draw the border
  
          // Restore the previous transformation matrix
          ctx.restore();
  
  
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, playerSize * 40, 0, 2 * Math.PI, false);
          ctx.fillStyle = 'blue';
          ctx.fill();
          ctx.lineWidth = 5;
          ctx.strokeStyle = 'darkblue';
          ctx.stroke();
  
          // Draw background bar
          ctx.fillStyle = 'black';
          ctx.fillRect((canvas.width / 2) - 50, (canvas.height / 2) + 55, 90, 10);
  
          ctx.textAlign = "center";
          ctx.font = "bold 20px Geneva";
          ctx.fillText(score, (canvas.width / 2), (canvas.height / 2) - 55);
  
          ctx.fillText(username, (canvas.width / 2), (canvas.height / 2) - 75);
  
          // Draw health bar
          const healthWidth = (playerHealth / 100) * 90;
          ctx.fillStyle = 'green';
          ctx.fillRect((canvas.width / 2) - 50, (canvas.height / 2) + 55, healthWidth, 10);
  
          // Draw border
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'grey';
          ctx.strokeRect((canvas.width / 2) - 50, (canvas.height / 2) + 55, 90, 10);
          ctx.strokeStyle = 'black'; // Or any color you want
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(mapLeft, mapTop);
          ctx.lineTo(mapRight, mapTop);
          ctx.lineTo(mapRight, mapBottom);
          ctx.lineTo(mapLeft, mapBottom);
          ctx.lineTo(mapLeft, mapTop);
          ctx.stroke();
  
  
          requestAnimationFrame(draw);
        }
        
        setInterval(() => {
          if (playerHealth <= 0) {
            socket.emit('playerDied', {id: playerId});
            document.getElementById('die').style.display = 'block';
            document.getElementById('container').style.display = 'none';
            document.getElementById('myCanvas').style.display = 'none';
            console.log(document.getElementById('die').style.display)
          }
          document.getElementById('players').innerText = `${playerX},${playerY}`;
        }, 100);
      }

      document.getElementById('playButton').addEventListener("mousedown", () => {
        username = document.getElementById('username').value;
        if (username) {
            // Proceed to the game with the entered username
            document.getElementById('start').style.display = 'none';
            document.getElementById('game').style.display = 'block';
            console.log(`Username: ${username}`,document.getElementById('start').style.display);
            ongame();
        } else {
            alert('Please enter a username.');
        }
      });
      
      
    </script>
  </body>
</html>